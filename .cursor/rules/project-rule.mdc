## Python Project Rules

### üîÑ Project Awareness & Context

- **Always read PLANNING.md** at the start of a new conversation to understand the project's architecture, goals, style, and constraints.

- **Check TASK.md** before starting a new task. If the task isn't listed, add it with a brief description and today's date.

- **Use consistent naming conventions, file structure, and architecture patterns** as described in this PLANNING.md.

### üß± Code Structure & Modularity

- **Never create a file longer than 1000 lines of code.** If a file approaches this limit, refactor by splitting it into modules or helper files.

- **Organize code into clearly separated modules**, grouped by feature or responsibility.

- **Use clear, consistent imports** following PEP 8 guidelines:
  - Standard library imports first
  - Third-party imports second  
  - Local application imports last
  - Use absolute imports when possible

- **Follow Python package structure**:
  ```
  project/
  ‚îú‚îÄ‚îÄ backend/
  ‚îÇ   ‚îú‚îÄ‚îÄ app/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/
  ‚îÇ   ‚îú‚îÄ‚îÄ tests/
  ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
  ‚îÇ   ‚îî‚îÄ‚îÄ server.py
  ‚îú‚îÄ‚îÄ web/
  ‚îî‚îÄ‚îÄ pyproject.toml
  ```

### ‚úÖ Task Completion

- **Mark completed tasks in TASK.md** immediately after finishing them.

- Add new sub-tasks or TODOs discovered during development to TASK.md under a "Discovered During Work" section.

### üìé Style & Structure

**Python Code Standards:**
- Follow PEP 8 style guidelines strictly
- Use type hints for all function parameters and return values
- Prefer functional programming patterns; avoid unnecessary classes
- Use descriptive variable names with clear intent (e.g., `is_valid`, `has_appointments`, `should_schedule`)
- Structure modules: imports, constants, functions, classes, main execution

**Naming Conventions:**
- Use snake_case for variables, functions, and module names
- Use PascalCase for class names
- Use UPPER_CASE for constants
- Use lowercase with underscores for directories (e.g., `medical_providers`, `appointment_scheduler`)

**Function and Class Design:**
- Write pure functions when possible
- Use dataclasses or Pydantic models for data structures
- Implement single responsibility principle
- Use early returns and guard clauses
- Keep functions under 50 lines when possible

**Error Handling and Validation:**
- Prioritize error handling: handle errors and edge cases early
- Use custom exception classes for domain-specific errors
- Implement proper logging with structured logging (use `structlog` or `loguru`)
- Use Pydantic for data validation and serialization
- Model expected errors as return values using Result types or Optional
- Use proper exception handling with specific exception types

**Performance and Best Practices:**
- Use async/await for I/O operations
- Implement connection pooling for database operations
- Use lazy loading for expensive operations
- Implement proper caching strategies
- Use context managers for resource management

**Key Libraries and Patterns:**
- Use `pydantic` for data validation and settings management
- Use `sqlalchemy` for database operations with async support
- Use `fastapi` for API endpoints if needed
- Use `pytest` for testing with fixtures and parametrization
- Use `black` for code formatting
- Use `mypy` for static type checking
- Use `ruff` or `flake8` for linting

### üìö Documentation & Explainability

- **Update README.md** when new features are added, dependencies change, or setup steps are modified.

- **Use comprehensive docstrings** following Google or NumPy style:
  ```python
  def calculate_optimal_provider(
      symptoms: List[str], 
      insurance_type: str, 
      location: str
  ) -> OptimalProviderResult:
      """Calculate the optimal medical provider based on user criteria.
      
      Args:
          symptoms: List of user-reported symptoms
          insurance_type: Type of insurance coverage
          location: User's location (state/city)
          
      Returns:
          OptimalProviderResult containing provider details and booking link
          
      Raises:
          NoProvidersFoundError: When no suitable providers are available
          InvalidInsuranceError: When insurance type is not supported
      """
  ```

- **Comment complex logic** with inline comments explaining the reasoning

- **Maintain type stubs** for external libraries when needed

### üß† AI Behavior Rules

- **Never assume missing context. Ask questions if uncertain.**

- **Never hallucinate libraries or functions** ‚Äì only use known, verified Python packages from PyPI.

- **Always confirm file paths and module names** exist before referencing them in code or tests.

- **Never delete or overwrite existing code** unless explicitly instructed to or if part of a task from TASK.md.

- **Use proper Python project structure** with virtual environments and dependency management.

### üîß Development Workflow

- **Use virtual environments** (venv, conda, or poetry) for dependency isolation
- **Pin dependency versions** in requirements.txt or pyproject.toml
- **Write tests first** when implementing new features (TDD approach)
- **Use pre-commit hooks** for code quality checks
- **Implement CI/CD** with Jenkins for automated testing and deployment


### üèóÔ∏è Architecture Patterns

- **Use dependency injection** for service layer components
- **Implement repository pattern** for data access
- **Use factory pattern** for object creation when appropriate
- **Apply SOLID principles** in class design
- **Implement proper separation of concerns** between layers (presentation, business logic, data access) 
- **Use factory pattern** for object creation when appropriate
- **Apply SOLID principles** in class design
- **Implement proper separation of concerns** between layers (presentation, business logic, data access) 